- 데이터베이스 정규화
  저번 시간에 정규형에 대해서 정리했으니, 이번 시간엔 좀 더 이론적인 내용을 조사해봤다.
  ## 데이터베이스 정규화란?
  **정규화**란 관계형 데이터베이스를 설계할 때 **데이터의 중복을 최소화**하고 **데이터 무결성을 개선**하기 위해, 테이블 구조를 체계적으로 만들어 나가는 '과정'을 의미한다.
  ***
  ## 정규화의 핵심 목표: '데이터 이상 현상' 해결
  정규화를 하는 가장 근본적인 이유는 데이터 수정 시 발생하는 '이상 현상(Anomaly)'을 방지하여 데이터의 일관성을 지키기 위함이다.
  - **갱신 이상 (Update Anomaly)**
    중복 저장된 데이터 중 일부만 수정되어 데이터가 서로 불일치하게 되는 문제이다. (예: 학생의 주소를 바꿨는데, 일부 레코드에만 반영되어 주소가 여러 개가 되는 현상)
  - **삽입 이상 (Insertion Anomaly)**
    원하지 않는 불필요한 데이터 없이는 새 데이터를 추가할 수 없는 문제이다. (예: 아직 수강하는 학생이 없는 신규 강의 정보를 등록할 수 없는 현상)
  - **삭제 이상 (Deletion Anomaly)**
    어떤 데이터를 삭제했을 때, 유지되어야 할 다른 정보까지 의도치 않게 함께 삭제되는 문제이다. (예: 마지막 수강생의 신청을 취소했더니, 강의 정보 자체가 사라져 버리는 현상)
  ***
  ## 정규화의 추가적인 목적
  이상 현상 해결 외에도 정규화는 다음과 같은 중요한 목적을 가진다.
  - **데이터 구조 확장 용이성**: 새로운 데이터 종류가 추가될 때, 기존 테이블 구조의 변경을 최소화하여 애플리케이션에 미치는 영향을 줄인다. → 이미 다 쪼개져 있기 때문에 유연하게 대응 가능.
  - **의미 있는 데이터 모델**: 테이블 구조가 현실 세계의 개념들을 더 잘 반영하게 되어 사용자가 데이터를 이해하기 쉬워진다.
  - **다양한 쿼리 지원**: 잘 정규화된 구조는 예상치 못했던 미래의 다양한 질문(Query)에도 유연하게 대응할 수 있다. → 이번 실전 쿼리 워크북 내용 같은것들
  ***
  ## 정규화의 장단점
  정규화는 데이터 무결성을 위한 강력한 원칙이지만, 현실에서는 성능과의 트레이드오프를 고려해야 한다.
  - **장점**
    - 데이터 중복이 사라져 **데이터 무결성**이 향상된다.
    - 데이터 구조가 깔끔하고 유연해져 **유지보수 및 확장**이 쉬워진다.
  - **단점**
    - 데이터가 여러 테이블로 잘게 쪼개져, 원하는 정보를 얻기 위해 더 많은 **JOIN 연산**이 필요해진다.
    - JOIN이 많아지면 **쿼리가 복잡해지고 조회(SELECT) 성능이 저하**될 수 있다.
  ***
  출처: https://ko.wikipedia.org/wiki/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4_%EC%A0%95%EA%B7%9C%ED%99%94
- 인덱스(Index)

  ## 인덱스(Index)란?

  데이터베이스에서 **검색 속도를 비약적으로 향상시키는 자료구조**. **책갈피 / 목차** 와 같은 역할을 한다. 목차가 없으면 책을 처음부터 다 읽어야 하지만, 목차가 있으면 원하는 페이지로 바로 이동할 수 있는 것과 같다.

  ***

  ## 인덱스의 특징

  - 항상 정렬된 상태를 유지한다. (인덱스 자체도 사전순 정렬)
  - 인덱스가 설정된 컬럼은 **조회 성능이 좋고**, **쓰기 성능**은 좋지 못하다.
    → **데이터가 삽입, 수정, 삭제될 때마다 인덱스도 항상 정렬 작업을 수행해야 하기 때문.**
    ⇒ 즉, 인덱스는 쓰기 성능을 희생하여 조회 성능을 높인다.
    **ETC) DB 크기의 약 10% 정도의 추가 공간 필요**

  ***

  ## 인덱스를 설정하면 좋은 경우

  ⇒ 쓰기가 자주 안일어나고, **조회**가 빈번한 컬럼에 쓰는게 좋다!

  - 테이블 규모가 작지 않음
  - INSERT, UPDATE, DELETE가 자주 발생하지 않는 쓰기 작업이 적은 컬럼
  - JOIN, WHERE, ORDER BY 등 조건에 자주 사용되는 컬럼
  - 데이터의 중복도(Cardinality)가 낮은 컬럼 → 이게 무슨 말일까?
  - 중복도에 대한 블로그의 예시 FEAT. 백종원의 김치볶음밥
    1. 요리 레시피 책에서는 여러 요리사의 요리 레시피가 담겨 있다고 해봅시다.
       앞의 비유의 예시에서는 책의 색인이 음식의 요리 종류로 설정되어 있었습니다.
    1. 제가 찾고 싶은 것이 더 구체적으로 ‘백종원의 김치볶음밥’이라고 한다면,
       책에서는 백종원 이외의 다른 요리사의 김치볶음밥도 담겨 있을 것입니다.
    1. 이때 책의 색인이 ‘음식의 요리 종류’로 설정되어 있기 때문에
       ‘백종원의 김치볶음밥’을 찾을 때 단순히 ‘김치볶음밥’으로 원하는 페이지를 찾게 될 것입니다.
    1. 만약 김치볶음밥 레시피가 중복되지 않고 ‘백종원의 김치볶음밥’ 하나라면
       해당하는 색인에 맞는 페이지를 바로 찾을 수 있겠지만,
       여러 요리사의 김치볶음밥 레시피가 존재한다면 ‘김치볶음밥’ 색인만으로는 중복도가 낮은 색인보다 검색 효율이 떨어질 것입니다.
       이처럼 데이터의 중복도가 낮지 않은 컬럼에 인덱스를 설정했을 때 효율이 떨어짐을 알 수 있습니다.

  ***

  ## 인덱스의 대표적인 자료구조

  - **해시 테이블 (Hash Table)**

    ![image.png](attachment:6382c876-5a37-44d4-9700-1fcfcbed3ffb:image.png)

    - Key-Value 형태로, `O(1)`의 매우 빠른 검색 속도를 가진다.
    - 하지만 **'=' (등호) 연산에만 특화**되어 있어, 범위를 검색하는 `>`나 `<` 같은 부등호 연산에는 부적합해 DB 인덱스로는 제한적으로 사용된다.

  - **B+Tree**
    ![image.png](attachment:99405550-c954-46e8-be8c-82a52b611ffc:image.png)
    - **DB 인덱스에서 가장 일반적으로 사용**되는 자료구조.
    - 기존 B-Tree를 개선하여, 데이터는 가장 마지막 노드(리프 노드)에만 저장하고, 이 리프 노드들을 **링크드 리스트(Linked List)로 연결**해 뒀다.
    - 이 구조 덕분에 특정 값을 찾는 것은 물론, **범위를 지정해 순차적으로 검색하는 작업에도 매우 효율적이**다.
      PS. 데베 시간때 해쉬까지는 배웠는데, B+ Tree는 스킵해서.. 아직도 이해가 잘 안된다.

  ***

  ## 인덱스 종류와 생성 방식

  ### 인덱스의 종류

  | 구분                 | 클러스터형 인덱스 (프라이머리)         | 보조 인덱스 (세컨더리)                         |
  | -------------------- | -------------------------------------- | ---------------------------------------------- |
  | **데이터 저장 방식** | 데이터 자체가 인덱스 순서로 **정렬됨** | 인덱스를 별도 공간에 저장 후 **위치를 가리킴** |
  | **비유**             | 영어사전                               | 책 찾아보기 (색인)                             |
  | **테이블당 개수**    | **1개**                                | **여러 개**                                    |

  ### 자동 생성

  1.  **기본키로 생성**
      테이블 생성시 기본키를 지정해주게 되면 그 기본키를 기준으로 하는 **하나의 클러스터형 인덱스**를 가진다.
      이 인덱스를 **기본 키 인덱스(Primary Key Index)**라고도 한다.

          - DDL에 기본 키 제약조건 명시

          ```sql
          CREATE TABLE employees (
              employee_id INT NOT NULL,
              first_name VARCHAR(50),
              last_name VARCHAR(50),
              PRIMARY KEY (employee_id)
          );
          ```

          - 만약 DDL에서 기본 키 제약조건을 명시하지 않았다면

          ```sql
          CREATE TABLE employees (
              employee_id INT NOT NULL,
              first_name VARCHAR(50),
              last_name VARCHAR(50)
          );

          ALTER TABLE employees
          ADD CONSTRAINT pk_employee_id PRIMARY KEY (employee_id)
          ```

          **2. UNIQUE 제약조건으로 생성**

          테이블의 컬럼에 유일 값을 가지게 하는 **UNIQUE**로 설정하게 되면 그 컬럼을 기준으로 하는 **하나의 보조형 인덱스**를 가진다.

          - DDL로 UNIQUE 제약조건 명시

          ```sql
          CREATE TABLE employees (
              employee_id INT NOT NULL,
              email VARCHAR(100) NOT NULL,
              first_name VARCHAR(50),
              last_name VARCHAR(50),
              PRIMARY KEY (employee_id),
              UNIQUE (email)
          );
          ```

          - DDL에 UNIQUE 제약조건을 명시하지 않은 경우

          ```sql
          CREATE TABLE employees (
              employee_id INT NOT NULL,
              email VARCHAR(100) NOT NULL,
              first_name VARCHAR(50),
              last_name VARCHAR(50),
              PRIMARY KEY (employee_id)
          );

          ALTER TABLE employees
          ADD CONSTRAINT unique_email UNIQUE (email);
          ```

  2.  **수동 생성**

          **CREATE** **INDEX** [인덱스 이름] **ON** [테이블 이름](컬럼 이름) ⇒ **보조 인덱스가 생성된다.**

          - 예시

          ```sql
          CREATE TABLE employees (
              employee_id INT NOT NULL,
              first_name VARCHAR(50),
              last_name VARCHAR(50),
              department_id INT,
              PRIMARY KEY (employee_id)
          );
          CREATE INDEX idx_department_id ON employees (department_id);
          ```

      ⇒ 사실상 우리가 테이블을 만들 때 **기본 키(PK)를 지정하는 것만으로도 데이터베이스가 알아서 가장 중요한 인덱스(클러스터형 인덱스)를 하나 생성한다. ⇒ 그래서 기본적으로 PK 기준 조회 쿼리문은 매우 빠르게 동작한다함.**

  ***

  출처: https://jaehee1007.tistory.com/131
  https://ksh-coding.tistory.com/122
  https://mangkyu.tistory.com/96#recentEntries

- ORM VS Raw SQL

  ## ORM 이란?

  ORM(Object-Relational Mapping)은 객체 지향 프로그래밍 언어를 사용하여 호환되지 않는 유형의 시스템 간에 데이터를 변환하는 프로그래밍 기술이다. 즉, 객체와 관계형 데이터베이스의 데이터를 매핑하는 것을 의미한다.

  > 쉽게 말해, DB의 데이터를 객체처럼 취급해 다룰 수있게 해주는.. **‘번역기’** 같은 기술.
  > **예를 들어,** 개발자가 객체를 조작하면(예: `user.name = "김철수"`), ORM이 중간에서 이를 알아서 적절한 SQL 쿼리(예: `UPDATE users SET name = '김철수' WHERE id = 1`)로 번역하여 데이터베이스에 전달해 준다.
  > 이를 통해 개발자는 SQL 쿼리를 직접 작성하지 않고도 자신이 사용하는 프로그래밍 언어만으로 데이터베이스 작업을 수행할 수 있다.

  ***

  ## ORM의 주요 기능과 장점

  - **생산성 향상**: 개발자는 복잡한 SQL 대신 객체지향 코드에만 집중할 수 있어 개발 과정을 단순화하고 시간을 단축시킨다.
  - **유지보수 용이성**: SQL 코드가 코드에서 분리되므로 가독성이 높아지고 유지보수가 쉬워진다. 데이터베이스 구조가 변경되어도 코드 수정이 최소화되어 유연한 대응이 가능하다.
  - **데이터베이스 독립성**: ORM이 각 데이터베이스에 맞는 SQL을 자동으로 생성해주므로, 애플리케이션 코드 변경 없이 다른 종류의 데이터베이스로 쉽게 전환할 수 있다.

  ***

  ## ORM 사용 시 고려사항

  - **성능 저하 가능성**: ORM이 생성하는 SQL은 특정 상황에 최적화되지 않아, 직접 작성한 SQL보다 성능이 저하될 수 있다. 성능이 중요한 서비스에서는 철저한 테스트가 필요하다.
  - **복잡한 쿼리의 한계**: 매우 복잡하거나 세밀한 제어가 필요한 쿼리는 ORM으로 표현하기 어려울 수 있다. 이 경우 직접 SQL을 작성하는 것이 더 효과적일 수 있다.
  - **모델 불일치 문제**: 객체 지향 모델과 관계형 데이터베이스 모델 간의 구조적 차이 때문에, 이를 매핑하는 과정에서 추가적인 설정이나 작업이 필요할 수 있다.
    - **예시**: 상속 관계를 DB에 저장할때 문제 발생. → DB에는 상속이라는 개념이 없다.

  ```sql
  간단한 예시: 직원 클래스를 상속받는 매니저 객체를 DB 테이블에 어떻게 저장할 것인가의 문제.

  해결 전략 (개발자의 '추가 설정'): 개발자는 ORM에게 아래와 같은 전략을 명시적으로 설정하여 이 문제를 해결한다.

  - 단일 테이블 전략: 모든 정보를 하나의 큰 테이블에 저장. (조회는 빠르나 공간 낭비)

  - 조인 테이블 전략: @Inheritance(strategy = "JOINED") 클래스별로 테이블을 분리하고 JOIN으로 연결. (데이터는 깔끔하나 조인 비용 발생)
  ```

  ***

  ## ORM VS RAW SQL

  | 구분          | ORM                 | Raw SQL           |
  | ------------- | ------------------- | ----------------- |
  | **핵심 가치** | **생산성 & 안정성** | **성능 & 통제력** |
  | **장점**      | - **높은 생산성**   |

  - **뛰어난 안정성/보안**
  - **유연한 유지보수 (DB 종류 바껴도 수정 X)**
  - **직관적인 코드** | - **최고의 성능**
  - **완벽한 통제력**
  - **깊은 이해도**
  - **명확성** |
    | **단점** | - **성능 저하 가능성**
  - **학습 곡선**
  - **제한적인 기능** | - **낮은 생산성**
  - **유지보수 어려움**
  - **보안 취약 (SQL 인젝션 등등 )** |
    | **추천 상황** | 일반적인 대부분의 데이터 처리, 빠른 프로토타이핑, 비즈니스 로직이 중요한 애플리케이션 | 대규모 데이터 처리, 복잡한 통계 및 분석 쿼리, 1ms의 성능도 중요한 서비스 |

  ### 결론

  정답은 없고, 상황에 따라 잘 섞어써야함 → 일반적인 데이터 작업은 ORM에 맡기고, 복잡한 성능이 중요한 부분에서는 직접 SQL을 작성하는 유연함을 가지는게 좋다~!

  ***

  ### PS.

  BE 프레임워크별 대표 ORM
  **Spring** - JPA & Hibernate
  **Django** - Django ORM
  **Node.js** - Sequelize, TypeORM, Prisma, Knex ( 이 중 골라쓴다함 )

  ***

  출처: https://f-lab.kr/insight/understanding-orm

  ***
